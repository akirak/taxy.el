#+TITLE: taxy.el

#+PROPERTY: LOGGING nil

# Note: This readme works with the org-make-toc <https://github.com/alphapapa/org-make-toc> package, which automatically updates the table of contents.

# [[https://melpa.org/#/package-name][file:https://melpa.org/packages/taxy-badge.svg]] [[https://stable.melpa.org/#/package-name][file:https://stable.melpa.org/packages/taxy-badge.svg]]

This library provides a way to programmably categorize arbitrary objects into a hierarchical taxonomy.  (That's a lot of fancy words to say that this lets you put things in groups.)

* Examples

This is a silly taxonomy of numbers below 100:

#+BEGIN_SRC elisp
  ("Numbery" "A silly taxonomy of numbers."
   (("< 10" "Numbers below 10"
     (0 2 4 6 8)
     (("Odd (consuming)"
       (1 3 5 7 9))
      ("Even (non-consuming)"
       (0 2 4 6 8))))
    (">= 10" "Numbers above 9"
     (10 11 13 14 17 19 22 23 25 26 29 31 34 35 37 38 41 43 46 47 49 50 53 55 58
         59 61 62 65 67 70 71 73 74 77 79 82 83 85 86 89 91 94 95 97 98)
     (("Divisible by 3 (non-consuming)"
       (12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84
           87 90 93 96 99))
      ("Divisible by 4 (non-consuming)"
       (12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96))
      ("Divisible by 3 or 4 (consuming)"
       (12 15 16 18 20 21 24 27 28 30 32 33 36 39 40 42 44 45 48 51 52 54 56 57 60
           63 64 66 68 69 72 75 76 78 80 81 84 87 88 90 92 93 96 99))
      ("Divisible by 5 (non-consuming)"
       (10 25 35 50 55 65 70 85 95))))))
#+END_SRC

You might think about how to produce that by writing some imperative code, but =taxy= allows you to do so in a more declarative and functional manner:

#+BEGIN_SRC elisp :exports code
  (require 'taxy)

  (let ((numbery
         (make-taxy
          :name "Numbery"
          :description "A silly taxonomy of numbers."
          :taxys (list (make-taxy
                        :name "< 10"
                        :description "Numbers below 10 (consuming)"
                        :predicate (lambda (n) (< n 10))
                        :taxys (list (make-taxy :name "Odd (consuming)"
                                                :predicate #'oddp)
                                     (make-taxy :name "Even (non-consuming)"
                                                :predicate #'evenp
                                                :then #'identity)))
                       (make-taxy
                        :name ">= 10"
                        :description "Numbers above 9 (consuming)"
                        :predicate (lambda (n) (>= n 10))
                        :taxys (list (make-taxy :name "Divisible by 3 (non-consuming)"
                                                :predicate (lambda (n) (zerop (mod n 3)))
                                                :then #'identity)
                                     (make-taxy :name "Divisible by 4 (non-consuming)"
                                                :predicate (lambda (n) (zerop (mod n 4)))
                                                :then #'identity)
                                     (make-taxy :name "Divisible by 3 or 4 (consuming)"
                                                :predicate (lambda (n) (or (zerop (mod n 3))
                                                                           (zerop (mod n 4)))))
                                     (make-taxy :name "Divisible by 5 (non-consuming)"
                                                :predicate (lambda (n) (zerop (mod n 5)))
                                                :then #'identity))))))
        (numbers (cl-loop for i below 100 collect i)))
    (taxy-simple (taxy-fill numbery (reverse numbers))))
#+END_SRC

The ~taxy-fill~ function applies the numbers in a "cascade" down the hierarchy of "taxys", and the ~taxy-simple~ function returns a meaningful subset of the taxys' slots, suitable for display.

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include siblings
:END:
:CONTENTS:
  -  [[#installation][Installation]]
  -  [[#usage][Usage]]
  -  [[#changelog][Changelog]]
  -  [[#credits][Credits]]
  -  [[#development][Development]]
  -  [[#license][License]]
:END:

# * Installation
# :PROPERTIES:
# :TOC:      :depth 0
# :END:
# 
# ** MELPA
# 
# If you installed from MELPA, you're done.  Just run one of the commands below.
# 
# ** Manual
# 
#   Install these required packages:
# 
#   + =foo=
#   + =bar=
# 
#   Then put this file in your load-path, and put this in your init file:
# 
#   #+BEGIN_SRC elisp
# (require 'taxy)
#   #+END_SRC

* Usage
:PROPERTIES:
:TOC:      :depth 0
:END:

A taxy is defined with the ~make-taxy~ constructor, like:

#+BEGIN_SRC elisp
  (make-taxy :name "Numbery"
             :description "A silly taxonomy of numbers."
             :predicate #'numberp
             :then #'ignore
             :taxys (list ...))
#+END_SRC

The ~:predicate~ function determines whether an object fits into that taxy.  If it does, ~taxy-fill~ adds the object to that taxy's descendant ~:taxys~, if present, or to its own ~objects~.  The function defaults to ~identity~, so a taxy "takes in" any object by default (i.e. if you only apply objects you want to classify, there's no need to test them at the top-level taxy).

The ~:then~ function determines what happens to an object after being taken in: if the function, called with the object, returns a non-nil value, that value is applied to other taxys at the same level until one of their ~:then~ functions returns nil or no more taxys remain.  The function defaults to ~ignore~, which makes a taxy "consume" its objects by default.  Setting the function to, e.g. ~identity~, makes it not consume them, leaving them eligible to also be taken into subsequent taxys, or to appear in the parent taxy's objects.

After defining a taxy, call ~taxy-fill~ with it and a list of objects to fill the taxy's hierarchy.

To return a taxy in a more human-readable format (with only relevant fields included), use ~taxy-simple~.

** Dynamic taxys

You may not always know in advance what taxonomy a set of objects fits into, so =taxy= lets you add taxys dynamically by using the ~:take~ function to add a taxy when an object is "taken into" a parent taxy.  For example, you could dynamically classify buffers by their major mode like so:

#+BEGIN_SRC elisp :exports code
  (let* ((key-fn (lambda (buffer)
                   (buffer-local-value 'major-mode buffer)))
         (buffery
          (make-taxy
           :name "Buffers"
           :taxys (list
                   (make-taxy
                    :name "Modes"
                    :take (lambda (buffer taxy)
                            (let* ((key (funcall key-fn buffer))
                                   (key-taxy
                                    (or (cl-find-if (lambda (taxy-key)
                                                      (equal key taxy-key))
                                                    (taxy-taxys taxy)
                                                    :key #'taxy-key)
                                        (car
                                         (push (make-taxy
                                                :name key :key key
                                                :predicate (lambda (buffer)
                                                             (equal key (funcall key-fn buffer))))
                                               (taxy-taxys taxy))))))
                              (push buffer (taxy-objects key-taxy)))))))))
    (taxy-simple (taxy-fill buffery (buffer-list))))
#+END_SRC

Which produces this taxonomy of buffers:

#+BEGIN_SRC elisp
  ("Buffers"
   (("Modes"
     ((magit-process-mode
       (#<buffer magit-process: taxy.el> #<buffer magit-process: > #<buffer magit-process: notes>))
      (messages-buffer-mode
       (#<buffer *Messages*>))
      (special-mode
       (#<buffer *Warnings*> #<buffer *elfeed-log*>))
      (dired-mode
       (#<buffer ement.el<emacs>>))
      (Custom-mode
       (#<buffer *Customize Apropos*>))
      (fundamental-mode
       (#<buffer  *helm candidates:Bookmarks*> #<buffer *Backtrace*>))
      (magit-diff-mode
       (#<buffer magit-diff: taxy.el> #<buffer magit-diff: notes> #<buffer magit-diff: ement.el>))
      (compilation-mode
       (#<buffer *compilation*> #<buffer *Compile-Log*>))
      (Info-mode
       (#<buffer  *helm info temp buffer*> #<buffer *info*>))
      (help-mode
       (#<buffer *Help*>))
      (emacs-lisp-mode
       (#<buffer ement.el<ement.el>> #<buffer ement-room-list.el> #<buffer *scratch*>
                 #<buffer ement-room.el> #<buffer init.el> #<buffer bufler.el>
                 #<buffer dash.el> #<buffer *Pp Eval Output*> #<buffer taxy.el> #<buffer scratch.el>))))))
#+END_SRC

# ** Tips
# 
# + You can customize settings in the =taxy= group.

* Changelog
:PROPERTIES:
:TOC:      :depth 0
:END:

** 0.1-pre

Not yet tagged.

# * Credits

* Development

Bug reports, feature requests, suggestions â€” /oh my/!

* License

GPLv3

# Local Variables:
# eval: (require 'org-make-toc)
# before-save-hook: org-make-toc
# org-export-with-properties: ()
# org-export-with-title: t
# End:


#+TITLE: taxy.el

#+PROPERTY: LOGGING nil

# Note: This readme works with the org-make-toc <https://github.com/alphapapa/org-make-toc> package, which automatically updates the table of contents.

#+HTML: <img src="images/mascot.png" align="right">

# [[https://melpa.org/#/package-name][file:https://melpa.org/packages/taxy-badge.svg]] [[https://stable.melpa.org/#/package-name][file:https://stable.melpa.org/packages/taxy-badge.svg]]

This library provides a programmable way to classify arbitrary objects into a hierarchical taxonomy.  (That's a lot of fancy words to say that this lets you put things in nested groups.)

Helpful features include:

+  Dynamic taxonomies :: Objects may be classified into hierarchies determined at runtime based on their attributes.
+  Reusable taxonomies :: Taxonomy definitions may be stored in variables and reused in other taxonomies' descendant groups.

* Example

This is a silly taxonomy of numbers below 100:

#+BEGIN_SRC elisp
  ("Numbery" "A silly taxonomy of numbers."
   (("< 10" "Numbers below 10"
     ;; These numbers are leftovers from the sub-taxys below.
     (0 2 4 6 8)
     ;; These sub-taxys further classify the numbers below 10 into odd
     ;; and even.  The odd taxy "consumes" numbers, while the even one
     ;; doesn't, leaving them to reappear in the parent taxy's objects.
     (("Odd (consuming)"
       (1 3 5 7 9))
      ("Even (non-consuming)"
       (0 2 4 6 8))))
    (">= 10" "Numbers above 9"
     ;; Like in the "< 10" taxy, these numbers are leftovers from this
     ;; taxy's sub-taxys, three of which are non-consuming.
     (10 11 13 14 17 19 22 23 25 26 29 31 34 35 37 38 41 43 46 47 49 50 53 55 58
         59 61 62 65 67 70 71 73 74 77 79 82 83 85 86 89 91 94 95 97 98)
     (("Divisible by 3 (non-consuming)"
       (12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84
           87 90 93 96 99))
      ("Divisible by 4 (non-consuming)"
       (12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96))
      ("Divisible by 3 or 4 (consuming)"
       ;; This taxy consumes numbers it takes in, but since these
       ;; numbers have already been taken in (without being consumed) by
       ;; the previous two sibling taxys, they may also appear in them.
       (12 15 16 18 20 21 24 27 28 30 32 33 36 39 40 42 44 45 48 51 52 54 56 57 60
           63 64 66 68 69 72 75 76 78 80 81 84 87 88 90 92 93 96 99))
      ("Divisible by 5 (non-consuming)"
       (10 25 35 50 55 65 70 85 95))))))
#+END_SRC

You might think about how to produce that by writing some imperative code, but =taxy= allows you to do so in a more declarative and functional manner:

#+BEGIN_SRC elisp :exports code
  (require 'taxy)

  (let ((numbery
         (make-taxy
          :name "Numbery"
          :description "A silly taxonomy of numbers."
          :taxys (list (make-taxy
                        :name "< 10"
                        :description "Numbers below 10 (consuming)"
                        :predicate (lambda (n) (< n 10))
                        :taxys (list
                                ;; These sub-taxys further classify the numbers below 10 into odd
                                ;; and even.  The odd taxy "consumes" numbers, while the even one
                                ;; doesn't, leaving them to reappear in the parent taxy's objects.
                                (make-taxy :name "Odd (consuming)"
                                           :predicate #'oddp)
                                (make-taxy :name "Even (non-consuming)"
                                           :predicate #'evenp
                                           :then #'identity)))
                       (make-taxy
                        :name ">= 10"
                        :description "Numbers above 9 (consuming)"
                        :predicate (lambda (n) (>= n 10))
                        :taxys (list
                                ;; Like in the "< 10" taxy, these sub-taxys further classify
                                ;; the numbers, but only one of them consumes numbers it
                                ;; takes in, leaving the rest to reappear in the parent taxy.
                                (make-taxy :name "Divisible by 3 (non-consuming)"
                                           :predicate (lambda (n) (zerop (mod n 3)))
                                           :then #'identity)
                                (make-taxy :name "Divisible by 4 (non-consuming)"
                                           :predicate (lambda (n) (zerop (mod n 4)))
                                           :then #'identity)
                                (make-taxy :name "Divisible by 3 or 4 (consuming)"
                                           ;; Since this taxy's `:then' function is unset,
                                           ;; it defaults to `ignore', which causes it to
                                           ;; consume numbers it takes in.  Since these
                                           ;; numbers have already been taken in (without
                                           ;; being consumed) by the previous two sibling
                                           ;; taxys, they also appear in them.
                                           :predicate (lambda (n) (or (zerop (mod n 3))
                                                                      (zerop (mod n 4)))))
                                (make-taxy :name "Divisible by 5 (non-consuming)"
                                           :predicate (lambda (n) (zerop (mod n 5)))
                                           :then #'identity))))))
        (numbers (cl-loop for i below 100 collect i)))
    (taxy-plain (taxy-fill (reverse numbers) numbery)))
#+END_SRC

The ~taxy-fill~ function applies the numbers in a "cascade" down the hierarchy of "taxys", and the ~taxy-plain~ function returns a meaningful subset of the taxys' slots, suitable for display.

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      :include siblings
:END:
:CONTENTS:
- [[#usage][Usage]]
  - [[#dynamic-taxys][Dynamic taxys]]
  - [[#reusable-taxys][Reusable taxys]]
- [[#changelog][Changelog]]
- [[#development][Development]]
- [[#license][License]]
:END:

# * Installation
# :PROPERTIES:
# :TOC:      :depth 0
# :END:
# 
# ** MELPA
# 
# If you installed from MELPA, you're done.  Just run one of the commands below.
# 
# ** Manual
# 
#   Install these required packages:
# 
#   + =foo=
#   + =bar=
# 
#   Then put this file in your load-path, and put this in your init file:
# 
#   #+BEGIN_SRC elisp
# (require 'taxy)
#   #+END_SRC

* Usage
:PROPERTIES:
:TOC:      :include descendants :depth 1
:END:
:CONTENTS:
- [[#dynamic-taxys][Dynamic taxys]]
- [[#reusable-taxys][Reusable taxys]]
:END:

A taxy is defined with the ~make-taxy~ constructor, like:

#+BEGIN_SRC elisp
  (make-taxy :name "Numbery"
             :description "A silly taxonomy of numbers."
             :predicate #'numberp
             :then #'ignore
             :taxys (list ...))
#+END_SRC

The ~:predicate~ function determines whether an object fits into that taxy.  If it does, ~taxy-fill~ adds the object to that taxy's descendant ~:taxys~, if present, or to its own ~:objects~.  The function defaults to ~identity~, so a taxy "takes in" any object by default (i.e. if you only apply objects you want to classify, there's no need to test them at the top-level taxy).

The ~:then~ function determines what happens to an object after being taken in: if the function, called with the object, returns a non-nil value, that value is applied to other taxys at the same level until one of their ~:then~ functions returns nil or no more taxys remain.  The function defaults to ~ignore~, which makes a taxy "consume" its objects by default.  Setting the function to, e.g. ~identity~, makes it not consume them, leaving them eligible to also be taken into subsequent taxys, or to appear in the parent taxy's objects.

After defining a taxy, call ~taxy-fill~ with it and a list of objects to fill the taxy's hierarchy.  *Note:* ~taxy-fill~ modifies the taxy given to it (filling its ~:objects~ and those of its ~:taxys~), so when using a statically defined taxy (e.g. one defined with ~defvar~), you should pass ~taxy-fill~ a taxy copied with ~taxy-copy~, which recursively copies a taxy without ~:objects~.

To return a taxy in a more human-readable format (with only relevant fields included), use ~taxy-plain~.  You may also use ~taxy-map~ to replace objects in a taxy with, e.g. a more useful representation.

** Dynamic taxys

You may not always know in advance what taxonomy a set of objects fits into, so =taxy= lets you add taxys dynamically by using the ~:take~ function to add a taxy when an object is "taken into" a parent taxy.  For example, you could dynamically classify buffers by their major mode like so:

#+BEGIN_SRC elisp :exports code
  (defun buffery-major-mode (buffer)
    (buffer-local-value 'major-mode buffer))

  (defvar buffery
    (make-taxy
     :name "Buffers"
     :taxys (list
             (make-taxy
              :name "Modes"
              :take (apply-partially #'taxy-take-keyed #'buffery-major-mode)))))

  ;; Note the use of `taxy-copy' to avoid mutating the original taxy definition.
  (taxy-plain
   (taxy-fill (buffer-list)
              (taxy-copy buffery)))
#+END_SRC

The taxy's ~:take~ function is set to the ~taxy-take-keyed~ function, partially applied with the ~buffery-major-mode~ function as its ~key-fn~ (~taxy-fill~ supplies the buffer and the taxy as arguments), and it produces this taxonomy of buffers:

#+BEGIN_SRC elisp
  ("Buffers"
   (("Modes"
     ((magit-process-mode
       (#<buffer magit-process: taxy.el> #<buffer magit-process: > #<buffer magit-process: notes>))
      (messages-buffer-mode
       (#<buffer *Messages*>))
      (special-mode
       (#<buffer *Warnings*> #<buffer *elfeed-log*>))
      (dired-mode
       (#<buffer ement.el<emacs>>))
      (Custom-mode
       (#<buffer *Customize Apropos*>))
      (fundamental-mode
       (#<buffer  *helm candidates:Bookmarks*> #<buffer *Backtrace*>))
      (magit-diff-mode
       (#<buffer magit-diff: taxy.el> #<buffer magit-diff: notes> #<buffer magit-diff: ement.el>))
      (compilation-mode
       (#<buffer *compilation*> #<buffer *Compile-Log*>))
      (Info-mode
       (#<buffer  *helm info temp buffer*> #<buffer *info*>))
      (help-mode
       (#<buffer *Help*>))
      (emacs-lisp-mode
       (#<buffer ement.el<ement.el>> #<buffer ement-room-list.el> #<buffer *scratch*>
                 #<buffer ement-room.el> #<buffer init.el> #<buffer bufler.el>
                 #<buffer dash.el> #<buffer *Pp Eval Output*> #<buffer taxy.el> #<buffer scratch.el>))))))
#+END_SRC

# ** Tips
# 
# + You can customize settings in the =taxy= group.

** Reusable taxys

Since taxys are structs, they may be stored in variables and used in other structs (being sure to copy the root taxy with ~taxy-copy~ before filling).  For example, this shows using =taxy= to classify Matrix rooms in [[https://github.com/alphapapa/ement.el][Ement.el]]:

#+BEGIN_SRC elisp
  (defun ement-roomy-buffer (room)
    (alist-get 'buffer (ement-room-local room)))

  (defvar ement-roomy-unread
    (make-taxy :name "Unread"
               :predicate (lambda (room)
                            (buffer-modified-p (ement-roomy-buffer room)))))

  (defvar ement-roomy-opened
    (make-taxy :name "Opened"
               :description "Rooms with buffers"
               :predicate #'ement-roomy-buffer
               :taxys (list ement-roomy-unread
                            (make-taxy))))

  (defvar ement-roomy-closed
    (make-taxy :name "Closed"
               :description "Rooms without buffers"
               :predicate (lambda (room)
                            (not (ement-roomy-buffer room)))))

  (defvar ement-roomy
    (make-taxy
     :name "Ement Rooms"
     :taxys (list (make-taxy
                   :name "Direct"
                   :description "Direct messaging rooms"
                   :predicate (lambda (room)
                                (ement-room--direct-p room ement-session))
                   :taxys (list ement-roomy-opened
                                ement-roomy-closed))
                  (make-taxy
                   :name "Non-direct"
                   :description "Group chat rooms"
                   :taxys (list ement-roomy-opened
                                ement-roomy-closed)))))
#+END_SRC

Note how the taxys defined in the first three variables are used in subsequent taxys.  As well, the ~ement-roomy-opened~ taxy has an "anonymous" taxy, which collects any rooms that aren't collected by its sibling taxy (otherwise those objects would be collected into the parent, "Opened" taxy, which may not always be the most useful way to present the objects).

Using those defined taxys, we then fill the ~ement-roomy~ taxy with all of the rooms in the user's session, and then use ~taxy-map~ to replace the room structs with useful representations for display:

#+BEGIN_SRC elisp
  (let ((ement-session (alist-get "@USER:HOST" ement-sessions nil nil #'equal)))
    (taxy-plain
     (taxy-map (lambda (room)
                   (list (ement-room--room-display-name room)
                         (ement-room-id room)))
       (taxy-fill (ement-session-rooms ement-session)
                  (taxy-copy ement-roomy)))))
#+END_SRC

This produces:

#+BEGIN_SRC elisp
  ("Ement Rooms"
   (("Direct" "Direct messaging rooms"
     (("Opened" "Rooms with buffers"
       (("Unread"
         (("Lars Ingebrigtsen" "!nope:gnus.org")))))
      ("Closed" "Rooms without buffers"
       (("John Wiegley" "!not-really:newartisans.com")
        ("Eli Zaretskii" "!im-afraid-not:gnu.org")))))
    ("Non-direct" "Group chat rooms"
     (("Opened" "Rooms with buffers"
       (("Unread"
         (("Emacs" "!WfZsmtnxbxTdoYPkaT:greyface.org")
          ("#emacs" "!KuaCUVGoCiunYyKEpm:libera.chat")))
        ;; The non-unread buffers in the "anonymous" taxy.
        ((("magit/magit" "!HZYimOcmEAsAxOcgpE:gitter.im")
          ("Ement.el" "!NicAJNwJawmHrEhqZs:matrix.org")
          ("#emacsconf" "!UjTTDnYmSAslLTtMCF:libera.chat")
          ("Emacs Matrix Client" "!ZrZoyXEyFrzcBZKNis:matrix.org")
          ("org-mode" "!rUhEinythPhVTdddsb:matrix.org")
          ("This Week in Matrix (TWIM)" "!xYvNcQPhnkrdUmYczI:matrix.org")))))
      ("Closed" "Rooms without buffers"
       (("#matrix-spec" "!NasysSDfxKxZBzJJoE:matrix.org")
        ("#commonlisp" "!IiGsrmKRHzpupHRaKS:libera.chat")
        ("Matrix HQ" "!OGEhHVWSdvArJzumhm:matrix.org")
        ("#lisp" "!czLxhhEegTEGNKUBgo:libera.chat")
        ("Emacs" "!gLamGIXTWBaDFfhEeO:matrix.org")
        ("#matrix-dev:matrix.org" "!jxlRxnrZCsjpjDubDX:matrix.org")))))))
#+END_SRC

* Changelog
:PROPERTIES:
:TOC:      :depth 0
:END:

** 0.1-pre

Not yet tagged.

# * Credits

* Development

Bug reports, feature requests, suggestions — /oh my/!

* License

GPLv3

# Local Variables:
# eval: (require 'org-make-toc)
# before-save-hook: org-make-toc
# org-export-with-properties: ()
# org-export-with-title: t
# End:

